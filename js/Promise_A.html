<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Promise_A</title>
</head>
<body>
  <script>
    // 由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。
    // 执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换
    // 是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve() 和 reject()。
    // 调用 resolve() 会把状态切换为兑现，调用 reject() 会把状态切换为拒绝。调用 reject() 也会抛出错误。

    let p = new Promise(() => {});
    setTimeout(console.log, 0, p); // Promise {<pending>}

    let p1 = new Promise((resolve, reject) => resolve()); 
    setTimeout(console.log, 0, p1); // Promise {<fulfilled>: undefined}

    let p2 = new Promise((resolve, reject) => reject());
    setTimeout(console.log, 0, p2); // Promise {<rejected>: undefined}

    // 在上面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。
    // 这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。

    new Promise(() => setTimeout(console.log, 0, 'executor'));
    setTimeout(console.log, 0, 'promise initialized');
    // executor
    // promise initialized

    // 添加 setTimeout 可以推迟切换状态。
    let p3 = new Promise((resolve, reject) => setTimeout(resolve, 1000)); // 1 秒后调用 reject() 
    // 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）
    setTimeout(console.log, 0, p3); // Promise {<pending>}
    setTimeout(console.log, 0, p3); // 1 秒后 // Promise {<fulfilled>: undefined}
    
    // 无论 resolve() 和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败。
    let p4 = new Promise((resolve, reject) => { 
     resolve();
     reject(); // 没有效果
    }); 
    setTimeout(console.log, 0, p4);
    // Promise {<fulfilled>: undefined}

    // 为避免期约卡在待定状态，可以添加一个定时退出功能。
    let p5 = new Promise((resolve, reject) => setTimeout(reject, 10000)); // 10 秒后调用 reject() 
    setTimeout(console.log, 0, p5); // Promise {<pending>}
    setTimeout(console.log, 11000, p5); // 11 秒后 // Promise {<rejected>: undefined}

    // 因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。
    // 如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。

    // 4. Promise.resolve();
    // 期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用
    // Promise.resolve() 静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：
    let pp1 = new Promise((resolve, reject) => resolve()); 
    let pp2 = Promise.resolve();

    // 这个解决的期约的值对应着传给 Promise.resolve() 的第一个参数。
    // 使用这个静态方法，实际上可以把任何值都转换为一个期约。
    setTimeout(console.log, 0, Promise.resolve()); // Promise {<fulfilled>: undefined}
    setTimeout(console.log, 0, Promise.resolve(3)); // Promise {<fulfilled>: 3}
    setTimeout(console.log, 0, Promise.resolve(4, 5, 6)); // Promise {<fulfilled>: 4}（多余的参数会忽略）

    // 对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。
    // Promise.resolve() 可以说是一个幂等方法。
    let pp3 = Promise.resolve(7); 
    setTimeout(console.log, 0, pp3 === Promise.resolve(pp3));                  // true
    setTimeout(console.log, 0, pp3 === Promise.resolve(Promise.resolve(pp3))); // true

    // 这个幂等性会保留传入期约的状态：
    let pp4 = new Promise(() => {}); 
    setTimeout(console.log, 0, pp4);                          // Promise {<pending>}
    setTimeout(console.log, 0, Promise.resolve(pp4));         // Promise {<pending>}
    setTimeout(console.log, 0, pp4 === Promise.resolve(pp4)); // true

    // 这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。也可能导致不符合预期的行为。
    let pp5 = Promise.resolve(new Error('foo')); 
    setTimeout(console.log, 0, pp5); // Promise {<fulfilled>: Error: foo}

    // 5. Promise.reject()
    // Promise.reject() 与 Promise.resolve() 类似，会实例化一个拒绝的期约并抛出一个异步错误
    // （这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际是一样的：
    let ppp1 = new Promise((resolve, reject) => reject()); // Uncaught (in promise) undefined
    let ppp2 = Promise.reject();                           // Uncaught (in promise) undefined

    // 这个拒绝的期约的理由就是传给 Promise.reject() 的第一个参数。这个参数也会传给后续的拒绝处理程序。 
    let ppp3 = Promise.reject(3); 
    setTimeout(console.log, 0, ppp3); // Promise {<rejected>: 3}
    ppp3.then(null, (e) => setTimeout(console.log, 0, e)); // 3

    // 关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个
    // 期约对象，则这个期约会成为它返回的拒绝期约的理由。
    setTimeout(console.log, 0, Promise.reject(Promise.resolve())); // Promise {<rejected>: Promise}
</script>
</body>
</html>